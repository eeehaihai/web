<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>吉大树洞 - 话题详情</title>
    <link rel="stylesheet" href="style.css">
    <script src="common.js"></script>
</head>
<body>
    <!-- 头部导航 -->
    <header>
        <div class="container header-content">
            <a href="home.html" class="logo">
                <h1>吉大树洞</h1>
            </a>

            <div class="user-actions">
                <!-- 此处会通过JS动态更新用户登录状态 -->
            </div>
        </div>
    </header>

    <div class="container">
        <div class="page-container topic-detail-container">
            <a href="javascript:history.back();" class="nav-link-top-left button-styled-back">返回</a>
            <!-- 话题详情区域 -->
            <div id="topicDetail" class="topic-detail">
                <div class="loading">正在加载话题内容...</div>
            </div>

            <!-- 评论列表区域 -->
            <div class="comment-section">
                <div class="comment-header">
                    <h2>全部评论 <span id="commentCount">0</span></h2>
                    <div class="comment-sort-options">
                        <a href="#" class="active" data-sort="floor_asc">正序</a>
                        <a href="#" data-sort="floor_desc">降序</a>
                        <a href="#" data-sort="hot">热门</a>
                    </div>
                </div>
                <div id="commentList" class="comment-list">
                    <div class="loading">正在加载评论...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- 浮动回复按钮 (用于回复话题) -->
    <div class="floating-reply-btn" id="floatingReplyBtnMainTopic" onclick="openReplyModalForTopic()">
        <span class="reply-icon">💬</span>
        <span class="reply-text">回复话题</span>
    </div>

    <!-- 回复话题的模态框 (居中) -->
    <div id="replyModal" class="reply-modal-overlay" style="display: none;">
        <div class="reply-modal-content" id="replyModalContent">
            <div class="reply-modal-header">
                <h3 id="replyModalTitle">回复话题</h3>
                <span class="reply-modal-close" onclick="closeReplyModal()">&times;</span>
            </div>
            <div class="reply-modal-body">
                <form id="replyForm">
                    <!-- parentCommentId, replyToFloor, replyToAuthor 仅用于主回复模态框，对于话题回复，这些值为空或0 -->
                    <input type="hidden" id="parentCommentId" name="parentCommentId" value="">
                    <input type="hidden" id="replyToFloor" name="replyToFloor" value="0">
                    <input type="hidden" id="replyToAuthor" name="replyToAuthor" value="">
                    
                    <div class="form-group">
                        <label for="reply_content" class="required">评论内容</label>
                        <textarea id="reply_content" name="reply_content" required placeholder="请输入您的评论内容..." rows="6"></textarea>
                        <div class="tips">文明发言，友善交流</div>
                    </div>

                    <!-- 图片上传区域，仅用于回复话题 -->
                    <div class="upload-section" id="modalUploadSection">
                        <label>添加图片</label>
                        <input type="file" id="images" name="images[]" class="file-input" accept="image/*" multiple>
                        <label for="images" class="file-label">选择图片</label>
                        <span id="file-count">未选择文件</span>
                        <div class="tips">最多可上传3张图片，每张不超过5MB</div>
                        <div class="files-preview" id="preview-container"></div>
                    </div>

                    <div class="form-group">
                        <div class="option-group">
                            <div class="checkbox-item">
                                <input type="checkbox" id="anonymous" name="anonymous" value="1">
                                <label for="anonymous">匿名评论</label>
                            </div>
                        </div>
                    </div>

                    <div id="message" class="message-box" style="display: none;"></div>
                </form>
            </div>
            <div class="reply-modal-footer">
                <button type="button" class="cancel-btn" onclick="closeReplyModal()">取消</button>
                <button type="button" class="submit-btn" onclick="submitReply()">发表评论</button>
            </div>
        </div>
    </div>

    <!-- 内联回复框 (用于回复评论/楼中楼) -->
    <div id="inlineReplyBox" class="inline-reply-box" style="display: none;">
        <input type="hidden" id="inlineParentCommentId">
        <input type="hidden" id="inlineReplyToFloor">
        <input type="hidden" id="inlineReplyToAuthor">
        <input type="hidden" id="inlineReplyToAuthorId"> <!-- 新增 -->
        <input type="hidden" id="inlineReplyTargetCommentId"> <!-- 新增 -->
        <textarea id="inlineReplyContent" placeholder="添加回复..." rows="2"></textarea>
        <div class="inline-reply-actions">
            <button type="button" class="inline-reply-submit-btn" onclick="submitInlineReply()">回复</button>
            <button type="button" class="inline-reply-cancel-btn" onclick="closeInlineReplyBox()">取消</button>
        </div>
        <div id="inlineReplyMessage" class="message-box" style="display: none; font-size: 0.9em; padding: 5px; margin-top: 5px;"></div>
    </div>

    <script>
        let currentSortBy = 'floor_asc';
        let isReplyModalDragging = false;
        let replyModalOffset = { x: 0, y: 0 };
        let currentTopicCommentsData = []; // 存储当前话题的所有评论
        const REPLIES_PER_PAGE = 5;
        let activeInlineReplyButton = null; // 追踪哪个按钮打开了内联回复框

        // 获取URL中的话题ID参数
        function getTopicId() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('id');
        }

        // 加载话题详情
        function loadTopicDetail() {
            const topicId = getTopicId();
            if (!topicId) {
                window.location.href = 'home.html';
                return;
            }

            const topicDetailEl = document.getElementById('topicDetail');
            topicDetailEl.innerHTML = '<div class="loading">正在加载话题内容...</div>';

            // 使用通用AJAX请求函数
            sendAjaxRequest('GET', `topics.php?id=${topicId}`, null,
                function(response) {
                    if (response.success && response.topic) {
                        const post = response.topic;

                        // 构建详情页HTML
                        const tagsHtml = post.tags && post.tags.length > 0
                            ? `<div class="topic-tags">${post.tags.map(tag => `<span class="tag">${safeHtml(tag)}</span>`).join('')}</div>`
                            : '';

                        // 添加删除按钮（仅对作者或管理员显示）
                        const currentUser = getCurrentUser();
                        const deleteButtonHtml = (currentUser && (currentUser === post.author || currentUser === 'admin'))
                            ? `<button id="deleteButton" class="action-button delete-button" onclick="deleteTopic('${topicId}')">
                                <span class="delete-icon">🗑️</span> 删除话题
                              </button>`
                            : '';

                        // 处理话题内容，确保HTML安全并正确显示换行
                        const safeContent = safeHtml(post.content).replace(/\n/g, '<br>');

                        // 构建图片HTML
                        const imagesHtml = post.images && post.images.length > 0
                            ? `<div class="topic-images-container">
                                ${post.images.map(imgPath => `<img src="${safeHtml(imgPath)}" alt="话题图片" class="topic-image" onclick="openImageModal(this.src)">`).join('')}
                               </div>`
                            : '';

                        // 添加作者信息、浏览量等
                        const topicHtml = `
                            <div class="topic-header">
                                <h1 class="detail-title">${safeHtml(post.title)}</h1>
                                <span class="topic-category">${safeHtml(post.categoryName)}</span>
                            </div>
                            <div class="topic-meta">
                                <span class="topic-author">${safeHtml(post.author)}</span>
                                <span class="topic-time">${formatTime(post.timestamp)}</span>
                                <span class="topic-views">浏览 ${post.views}</span>
                            </div>
                            <div class="topic-full-content">${safeContent}</div>
                            ${imagesHtml}
                            ${tagsHtml}
                            <div class="topic-stats">
                                <button id="likeButton" class="action-button ${post.currentUserLiked ? 'liked' : ''}" onclick="likeTopic('${topicId}')">
                                    <span class="like-icon">❤</span> 点赞 <span class="like-count-text">${post.likes || 0}</span>
                                </button>
                                <button class="action-button">
                                    <span class="comment-icon">💬</span> 评论 <span class="commentCount">${post.comments || 0}</span>
                                </button>
                                ${deleteButtonHtml}
                            </div>
                        `;

                        topicDetailEl.innerHTML = topicHtml;

                        // 更新页面标题
                        document.title = `${post.title} - 吉大树洞`;

                        // 加载评论
                        loadComments(topicId, currentSortBy);
                    } else {
                        topicDetailEl.innerHTML = '<div class="error-message">话题不存在或已被删除</div>';
                    }
                },
                function() {
                    topicDetailEl.innerHTML = '<div class="error-message">网络错误，请检查您的连接</div>';
                }
            );
        }

        // 删除话题
        function deleteTopic(topicId) {
            if (!confirm('确定要删除这个话题吗？此操作不可恢复！')) {
                return;
            }

            // 使用通用AJAX请求函数
            sendAjaxRequest('POST', 'delete_topic.php', { topicId: topicId },
                function(response) {
                    if (response.success) {
                        alert('话题删除成功！');
                        // 跳转到首页
                        window.location.href = 'home.html';
                    } else {
                        alert('删除失败：' + response.message);
                    }
                },
                function() {
                    alert('删除失败：网络错误');
                }
            );
        }

        // 点赞功能
        function likeTopic(topicId) {
            const likeButton = document.getElementById('likeButton');
            
            const likeCountSpan = likeButton ? likeButton.querySelector('.like-count-text') : null; 
            
            if (!checkLoginRequired()) return;

            // 使用通用AJAX请求函数
            sendAjaxRequest('POST', 'like_topic.php', { topicId: topicId },
                function(response) {
                    if (response.success) {
                        // 更新显示的点赞数
                        if (likeCountSpan) { 
                            likeCountSpan.textContent = response.likes;
                        }
                        // 更新按钮样式
                        if (response.isLikedByCurrentUser) {
                            likeButton.classList.add('liked');
                        } else {
                            likeButton.classList.remove('liked');
                        }
                    } else {
                        console.error('点赞/取消点赞失败:', response.message);
                        alert(response.message || '操作失败，请稍后再试');
                    }
                },
                function() {
                    console.error('点赞/取消点赞请求失败');
                    alert('网络错误，请稍后再试');
                }
            );
        }

        // 点赞评论功能
        function likeComment(topicId, commentId, event) {
            if (!checkLoginRequired()) return;
            // 如果点赞按钮在内联回复框内被点击，阻止内联回复框关闭
            if (event.target.closest('.inline-reply-box')) {
                 event.stopPropagation();
            }
            
            const likeButton = event.currentTarget;
            const likeCountSpan = likeButton.querySelector('.like-count-text');

            sendAjaxRequest('POST', 'like_comment.php', { topicId: topicId, commentId: commentId },
                function(response) {
                    if (response.success) {
                        if (likeCountSpan) {
                            likeCountSpan.textContent = response.likes;
                        }
                        if (response.isLikedByCurrentUser) {
                            likeButton.classList.add('liked');
                        } else {
                            likeButton.classList.remove('liked');
                        }
                    } else {
                        alert(response.message || '点赞/取消点赞失败');
                    }
                },
                function() {
                    alert('网络错误，点赞/取消点赞失败');
                }
            );
        }

        // 加载话题的评论
        function loadComments(topicId, sortBy = 'floor_asc') {
            const commentListEl = document.getElementById('commentList');
            const commentCountEl = document.getElementById('commentCount');

            commentListEl.innerHTML = '<div class="loading">正在加载评论...</div>';

            // 使用通用AJAX请求函数
            sendAjaxRequest('GET', `comments.php?topicId=${topicId}&sortBy=${sortBy}`, null,
                function(response) {
                    if (response.success) {
                        const comments = response.comments || [];
                        currentTopicCommentsData = comments; // 存储用于分页

                        // 计算总评论数（包括楼中楼回复）
                        let totalComments = 0;
                        comments.forEach(comment => {
                            totalComments++; // 主评论计1
                            if (comment.replies && comment.replies.length > 0) {
                                totalComments += comment.replies.length; // 楼中楼回复也计入
                            }
                        });

                        // 更新评论数量
                        commentCountEl.textContent = totalComments;

                        // 如果没有评论
                        if (comments.length === 0) {
                            commentListEl.innerHTML = '<div class="no-comments">暂无评论，快来发表第一条评论吧！</div>';
                            return;
                        }

                        // 显示所有评论
                        commentListEl.innerHTML = '';
                        comments.forEach((comment) => {
                            const commentEl = createCommentElement(comment, topicId);
                            commentListEl.appendChild(commentEl);
                        });
                    } else {
                        commentListEl.innerHTML = '<div class="error-message">加载评论失败</div>';
                    }
                },
                function() {
                    commentListEl.innerHTML = '<div class="error-message">网络错误，请检查您的连接</div>';
                }
            );
        }

        // 创建评论元素
        function createCommentElement(comment, topicId) {
            const commentEl = document.createElement('div');
            commentEl.className = 'comment-item';
            commentEl.setAttribute('data-comment-id', comment.id); // 添加data-id用于定位

            const safeContent = safeHtml(comment.content).replace(/\n/g, '<br>');
            const commentImagesHtml = comment.images && comment.images.length > 0
                ? `<div class="comment-images-container">
                    ${comment.images.map(imgPath => `<img src="${safeHtml(imgPath)}" alt="评论图片" class="comment-image" onclick="openImageModal(this.src)">`).join('')}
                   </div>`
                : '';
            const commentLikeButtonClass = comment.currentUserLiked ? 'comment-like liked' : 'comment-like';

            // 主评论结构
            commentEl.innerHTML = `
                <div class="comment-main">
                    <div class="comment-body">
                        <div class="comment-header">
                            <div class="comment-author-details">
                                <span class="comment-author">${safeHtml(comment.author)}</span>
                                <div class="comment-floor-number">${comment.floor}楼</div>
                            </div>
                            <span class="comment-time">${formatTime(comment.timestamp)}</span>
                        </div>
                        <div class="comment-content">${safeContent}</div>
                        ${commentImagesHtml}
                        <div class="comment-footer">
                            <button class="${commentLikeButtonClass}" onclick="likeComment('${topicId}', '${comment.id}', event)">
                                <span class="like-icon">👍</span> <span class="like-count-text">${comment.likes || 0}</span>
                            </button>
                            <button class="comment-reply-btn" onclick="openInlineReplyBox('${comment.id}', '${comment.floor}', '${safeHtml(comment.author)}', this, '${comment.id}', '${comment.author_user_id}')">
                                <span class="reply-icon">💬</span> 回复
                            </button>
                        </div>
                    </div>
                </div>
            `;

            // 处理楼中楼回复
            if (comment.replies && comment.replies.length > 0) {
                const allReplies = comment.replies;
                const repliesContainer = document.createElement('div');
                repliesContainer.className = 'comment-replies-container';
                
                const repliesHeader = document.createElement('div');
                repliesHeader.className = 'replies-header';
                repliesHeader.innerHTML = `
                    <span class="replies-count">${allReplies.length} 条回复</span>
                    <button class="toggle-replies-btn" onclick="toggleReplies(this, '${comment.id}', '${topicId}')">
                        <span class="toggle-text">展开</span>
                        <span class="toggle-icon">▼</span>
                    </button>
                `;
                
                const repliesContent = document.createElement('div');
                repliesContent.className = 'replies-content';
                repliesContent.id = `replies-content-${comment.id}`;
                repliesContent.style.display = 'none'; // 初始隐藏
                
                const repliesPagination = document.createElement('div');
                repliesPagination.className = 'replies-pagination';
                repliesPagination.id = `replies-pagination-${comment.id}`;
                repliesPagination.style.display = 'none'; // 初始隐藏

                repliesContainer.appendChild(repliesHeader);
                repliesContainer.appendChild(repliesContent);
                repliesContainer.appendChild(repliesPagination);
                commentEl.appendChild(repliesContainer);
            }

            return commentEl;
        }

        // 显示楼中楼回复的特定页面
        function displayRepliesPage(commentId, topicId, page) {
            // Ensure commentId is treated as a number for comparison if c.id is a number
            const mainCommentData = currentTopicCommentsData.find(c => c.id === parseInt(commentId)); 
            if (!mainCommentData || !mainCommentData.replies) return;

            const allReplies = mainCommentData.replies;
            const repliesContentEl = document.getElementById(`replies-content-${commentId}`);
            const paginationControlsEl = document.getElementById(`replies-pagination-${commentId}`);

            if (!repliesContentEl || !paginationControlsEl) return;

            repliesContentEl.innerHTML = ''; // 清空上一页
            paginationControlsEl.innerHTML = ''; // 清空上一页的控件

            const totalReplies = allReplies.length;
            const totalPages = Math.ceil(totalReplies / REPLIES_PER_PAGE);
            
            const startIndex = (page - 1) * REPLIES_PER_PAGE;
            const endIndex = Math.min(startIndex + REPLIES_PER_PAGE, totalReplies);
            const currentPageReplies = allReplies.slice(startIndex, endIndex);

            currentPageReplies.forEach(reply => {
                const replyEl = document.createElement('div');
                replyEl.className = 'reply-item';
                
                const replyContent = safeHtml(reply.content).replace(/\n/g, '<br>');
                const replyImagesHtml = reply.images && reply.images.length > 0
                    ? `<div class="comment-images-container">
                        ${reply.images.map(imgPath => `<img src="${safeHtml(imgPath)}" alt="回复图片" class="comment-image" onclick="openImageModal(this.src)">`).join('')}
                       </div>`
                    : '';
                const replyLikeButtonClass = reply.currentUserLiked ? 'comment-like liked' : 'comment-like';

                let displayContent = replyContent;
                if (reply.replyToFloor && reply.replyToAuthor) {
                    displayContent = `<span class="reply-target">回复 ${reply.replyToFloor}楼 @${safeHtml(reply.replyToAuthor)}:</span> ${replyContent}`;
                }

                replyEl.innerHTML = `
                    <div class="reply-header">
                        <span class="reply-author">${safeHtml(reply.author)}</span>
                        <span class="reply-time">${formatTime(reply.timestamp)}</span>
                    </div>
                    <div class="reply-content">${displayContent}</div>
                    ${replyImagesHtml}
                    <div class="reply-footer">
                        <button class="${replyLikeButtonClass}" onclick="likeComment('${topicId}', '${reply.id}', event)">
                            <span class="like-icon">👍</span> <span class="like-count-text">${reply.likes || 0}</span>
                        </button>
                        <button class="comment-reply-btn" onclick="openInlineReplyBox('${commentId}', '${mainCommentData.floor}', '${safeHtml(reply.author)}', this, '${reply.id}', '${reply.author_user_id}')">
                            <span class="reply-icon">💬</span> 回复
                        </button>
                    </div>
                `;
                repliesContentEl.appendChild(replyEl);
            });

            // 渲染分页控件
            if (totalPages > 1) {
                if (page > 1) {
                    const prevButton = document.createElement('button');
                    prevButton.textContent = '上一页';
                    prevButton.onclick = () => displayRepliesPage(commentId, topicId, page - 1);
                    paginationControlsEl.appendChild(prevButton);
                }

                for (let i = 1; i <= totalPages; i++) {
                    const pageButton = document.createElement('button');
                    pageButton.textContent = i;
                    if (i === page) {
                        pageButton.disabled = true;
                        pageButton.classList.add('active');
                    }
                    pageButton.onclick = () => displayRepliesPage(commentId, topicId, i);
                    paginationControlsEl.appendChild(pageButton);
                }

                if (page < totalPages) {
                    const nextButton = document.createElement('button');
                    nextButton.textContent = '下一页';
                    nextButton.onclick = () => displayRepliesPage(commentId, topicId, page + 1);
                    paginationControlsEl.appendChild(nextButton);
                }
            }
        }

        // 打开回复话题的模态框
        function openReplyModalForTopic() {
            const modal = document.getElementById('replyModal');
            const title = document.getElementById('replyModalTitle');
            const content = document.getElementById('reply_content');
            const parentIdInput = document.getElementById('parentCommentId');
            const replyFloorInput = document.getElementById('replyToFloor');
            const replyAuthorInput = document.getElementById('replyToAuthor');
            const uploadSection = document.getElementById('modalUploadSection');

            resetReplyForm(); // 重置主模态框表单

            title.textContent = '回复话题';
            content.placeholder = '请输入您的评论内容...';
            parentIdInput.value = ''; // 回复话题，无父评论
            replyFloorInput.value = '0';
            replyAuthorInput.value = '';
            uploadSection.style.display = 'block'; // 回复话题时显示图片上传

            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            content.focus();
        }
        
        // 关闭回复话题的模态框
        function closeReplyModal() {
            const modal = document.getElementById('replyModal');
            modal.style.display = 'none';
            document.body.style.overflow = 'auto';
            resetReplyForm();
        }

        // 重置回复话题的模态框表单
        function resetReplyForm() {
            document.getElementById('reply_content').value = '';
            document.getElementById('preview-container').innerHTML = '';
            document.getElementById('file-count').textContent = '未选择文件';
            document.getElementById('images').value = ''; // 清空文件输入
            document.getElementById('anonymous').checked = false;
            const messageEl = document.getElementById('message');
            messageEl.style.display = 'none';
            messageEl.className = 'message-box';
        }

        // 打开内联回复框 (用于回复评论/楼中楼)
        function openInlineReplyBox(parentCommentId, floor, author, buttonElement, replyTargetCommentId, replyTargetUserId) {
            if (!checkLoginRequired()) return;

            closeInlineReplyBox(); // 先关闭任何已存在的内联框

            activeInlineReplyButton = buttonElement;
            const inlineReplyBox = document.getElementById('inlineReplyBox');
            document.getElementById('inlineParentCommentId').value = parentCommentId; // 这是主评论的ID
            document.getElementById('inlineReplyToFloor').value = floor; // 这是被回复目标的楼层 (可能是主评论的楼层)
            document.getElementById('inlineReplyToAuthor').value = author; // 这是被回复目标的作者昵称
            document.getElementById('inlineReplyTargetCommentId').value = replyTargetCommentId; // 这是被直接回复的评论/回复的ID
            document.getElementById('inlineReplyToAuthorId').value = replyTargetUserId; // 这是被直接回复的评论/回复的作者的User ID
            
            const inlineContent = document.getElementById('inlineReplyContent');
            // 更新placeholder以反映回复的是谁
            const targetAuthorDisplay = author || '该用户';
            const targetFloorDisplay = floor ? `${floor}楼 ` : '';
            inlineContent.placeholder = `回复 ${targetFloorDisplay}@${targetAuthorDisplay}...`;
            inlineContent.value = ''; // 清空先前内容

            // 定位内联回复框
            const commentItem = buttonElement.closest('.comment-item, .reply-item'); // 找到父评论或回复项
            
            if (commentItem) {
                 // 追加到评论/回复项的页脚后，以获得更好的流程
                const footer = buttonElement.closest('.comment-footer, .reply-footer');
                if (footer) {
                    footer.parentNode.insertBefore(inlineReplyBox, footer.nextSibling);
                } else { // 如果未找到页脚，则追加到评论项
                    commentItem.appendChild(inlineReplyBox);
                }
            } else { // 回退：如果未找到评论项，则定位在按钮附近 (不应发生)
                const rect = buttonElement.getBoundingClientRect();
                inlineReplyBox.style.top = (window.scrollY + rect.bottom + 5) + 'px';
                inlineReplyBox.style.left = (window.scrollX + rect.left) + 'px';
                document.body.appendChild(inlineReplyBox); // 如果没有更好的位置，则追加到body
            }
            
            inlineReplyBox.style.display = 'block';
            inlineContent.focus();
            
            // 添加事件监听器，以便在点击外部时关闭
            // 使用setTimeout避免因打开它的点击而立即关闭
            setTimeout(() => {
                document.addEventListener('click', handleClickOutsideInlineReplyBox, true);
            }, 0);
        }

        function handleClickOutsideInlineReplyBox(event) {
            const inlineReplyBox = document.getElementById('inlineReplyBox');
            if (inlineReplyBox.style.display === 'block' && !inlineReplyBox.contains(event.target) && activeInlineReplyButton && !activeInlineReplyButton.contains(event.target)) {
                // 检查点击的是否是任何“回复”按钮，如果是，则不关闭，因为另一个会打开。
                if (!event.target.classList.contains('comment-reply-btn')) {
                    closeInlineReplyBox();
                }
            }
        }

        // 关闭内联回复框
        function closeInlineReplyBox() {
            const inlineReplyBox = document.getElementById('inlineReplyBox');
            if (inlineReplyBox) {
                inlineReplyBox.style.display = 'none';
                document.getElementById('inlineReplyContent').value = '';
                const messageEl = document.getElementById('inlineReplyMessage');
                messageEl.style.display = 'none';
                messageEl.className = 'message-box';

                // 确保它被追加到body并隐藏，为下次使用做准备
                // 这可以防止在重建评论列表时它变成孤立的
                if (inlineReplyBox.parentNode !== document.body) {
                    document.body.appendChild(inlineReplyBox);
                }

                document.removeEventListener('click', handleClickOutsideInlineReplyBox, true);
                activeInlineReplyButton = null;
            }
        }

        // 提交内联回复
        function submitInlineReply() {
            if (!isLoggedIn()) {
                alert('请先登录后再发表评论');
                window.location.href = 'login.html';
                return;
            }

            const topicId = getTopicId();
            const content = document.getElementById('inlineReplyContent').value.trim();
            const parentCommentId = document.getElementById('inlineParentCommentId').value;
            const replyToFloor = document.getElementById('inlineReplyToFloor').value;
            const replyToAuthor = document.getElementById('inlineReplyToAuthor').value;
            const messageEl = document.getElementById('inlineReplyMessage');

            if (!content) {
                showMessageElement(messageEl, '回复内容不能为空', 'error');
                return;
            }
            
            showMessageElement(messageEl, '', 'none'); // 清除先前的消息

            const replyTargetCommentId = document.getElementById('inlineReplyTargetCommentId').value; // 修正：使用正确的ID获取目标评论ID
            const replyTargetUserId = document.getElementById('inlineReplyToAuthorId').value; 

            const formData = new FormData();
            formData.append('topicId', topicId);
            formData.append('content', content);
            formData.append('parentCommentId', parentCommentId); // 主评论ID
            formData.append('replyTargetCommentId', replyTargetCommentId); // 目标评论ID
            formData.append('replyTargetUserId', replyTargetUserId); // 目标用户ID
            formData.append('anonymous', '0');

            sendAjaxRequest('POST', 'comments.php', formData,
                function(response) {
                    if (response.success) {
                        showMessageElement(messageEl, '回复成功！', 'success');
                        setTimeout(() => {
                            closeInlineReplyBox();
                            loadComments(topicId, currentSortBy);
                        }, 1000);
                    } else {
                        showMessageElement(messageEl, response.message || '回复失败！', 'error');
                    }
                },
                function() {
                    showMessageElement(messageEl, '网络错误！', 'error');
                }
            );
        }
        
        // 用于在特定元素中显示消息的辅助函数
        function showMessageElement(element, message, type) {
            if (!element) return;
            element.innerHTML = message;
            if (type === 'none') {
                element.style.display = 'none';
            } else {
                element.className = `message-box ${type}`;
                element.style.display = 'block';
            }
        }


        // 提交回复 (此函数现在仅用于回复话题的主模态框)
        function submitReply() {
            if (!isLoggedIn()) {
                alert('请先登录后再发表评论');
                window.location.href = 'login.html';
                return;
            }

            const topicId = getTopicId();
            const content = document.getElementById('reply_content').value.trim();
            const anonymous = document.getElementById('anonymous').checked;
            const imagesInput = document.getElementById('images');
            const parentCommentId = document.getElementById('parentCommentId').value; // 回复话题时应为空
            const replyToFloor = document.getElementById('replyToFloor').value; // 回复话题时应为0
            const replyToAuthor = document.getElementById('replyToAuthor').value; // 回复话题时应为空

            if (!content) {
                alert('评论内容不能为空');
                return;
            }

            const messageEl = document.getElementById('message');
            messageEl.style.display = 'none';

            const formData = new FormData();
            formData.append('topicId', topicId);
            formData.append('content', content);
            formData.append('anonymous', anonymous ? '1' : '0');
            formData.append('parentCommentId', parentCommentId);
            formData.append('replyToFloor', replyToFloor);
            formData.append('replyToAuthor', replyToAuthor);

            if (imagesInput.files.length > 0) {
                for (let i = 0; i < imagesInput.files.length; i++) {
                    formData.append('images[]', imagesInput.files[i]);
                }
            }

            sendAjaxRequest('POST', 'comments.php', formData,
                function(response) {
                    if (response.success) {
                        messageEl.innerHTML = '评论发表成功！';
                        messageEl.className = 'message-box success';
                        messageEl.style.display = 'block';

                        setTimeout(() => {
                            closeReplyModal();
                            loadComments(topicId, currentSortBy); // 重新加载话题评论
                        }, 1000);
                    } else {
                        messageEl.innerHTML = response.message || '评论发表失败，请稍后再试！';
                        messageEl.className = 'message-box error';
                        messageEl.style.display = 'block';
                    }
                },
                function() {
                    messageEl.innerHTML = '网络错误，请检查您的连接！';
                    messageEl.className = 'message-box error';
                    messageEl.style.display = 'block';
                }
            );
        }

        // 切换回复显示/隐藏
        function toggleReplies(button, commentId, topicId) {
            const repliesContainer = button.closest('.comment-replies-container');
            const repliesContent = repliesContainer.querySelector(`#replies-content-${commentId}`);
            const repliesPagination = repliesContainer.querySelector(`#replies-pagination-${commentId}`);
            const toggleText = button.querySelector('.toggle-text');
            const toggleIcon = button.querySelector('.toggle-icon');

            const isHidden = repliesContent.style.display === 'none';

            if (isHidden) {
                // 如果是第一次展开或内容为空（例如排序后），则渲染第一页
                if (repliesContent.innerHTML.trim() === '') {
                     displayRepliesPage(commentId, topicId, 1);
                }
                repliesContent.style.display = 'block';
                repliesPagination.style.display = 'flex'; // 分页按钮使用flex布局
                toggleText.textContent = '收起';
                toggleIcon.textContent = '▲';
            } else {
                repliesContent.style.display = 'none';
                repliesPagination.style.display = 'none';
                toggleText.textContent = '展开';
                toggleIcon.textContent = '▼';
            }
        }

        // 模态框拖拽功能
        function initModalDrag() {
            const modal = document.getElementById('replyModalContent');
            const header = modal.querySelector('.reply-modal-header');

            header.addEventListener('mousedown', function(e) {
                isReplyModalDragging = true;
                const rect = modal.getBoundingClientRect();
                replyModalOffset.x = e.clientX - rect.left;
                replyModalOffset.y = e.clientY - rect.top;
                header.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', function(e) {
                if (isReplyModalDragging) {
                    const x = e.clientX - replyModalOffset.x;
                    const y = e.clientY - replyModalOffset.y;
                    modal.style.left = Math.max(0, Math.min(x, window.innerWidth - modal.offsetWidth)) + 'px';
                    modal.style.top = Math.max(0, Math.min(y, window.innerHeight - modal.offsetHeight)) + 'px';
                }
            });

            document.addEventListener('mouseup', function() {
                if (isReplyModalDragging) {
                    isReplyModalDragging = false;
                    header.style.cursor = 'grab';
                }
            });
        }

        // 页面加载时执行
        document.addEventListener('DOMContentLoaded', function() {
            // 浮动回复按钮现在应调用 openReplyModalForTopic
            const mainFloatingReplyBtn = document.getElementById('floatingReplyBtnMainTopic');
            if (mainFloatingReplyBtn) {
                 mainFloatingReplyBtn.setAttribute('onclick', 'openReplyModalForTopic()');
            }

            updateNavUserStatus();
            loadTopicDetail();
            initModalDrag();

            // 设置评论排序点击事件
            document.querySelectorAll('.comment-sort-options a').forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();

                    // 移除之前的active类
                    document.querySelectorAll('.comment-sort-options a').forEach(item => {
                        item.classList.remove('active');
                    });

                    // 添加active类到当前点击项
                    this.classList.add('active');

                    // 更新排序方式并重新加载评论
                    currentSortBy = this.getAttribute('data-sort');
                    const topicId = getTopicId();
                    if (topicId) {
                        loadComments(topicId, currentSortBy);
                    }
                });
            });

            // 处理图片预览
            document.getElementById('images').addEventListener('change', function(e) {
                const fileCount = e.target.files.length;
                document.getElementById('file-count').textContent =
                    fileCount > 0 ? `已选择 ${fileCount} 个文件` : '未选择文件';

                const previewContainer = document.getElementById('preview-container');
                previewContainer.innerHTML = '';

                for(let i = 0; i < Math.min(fileCount, 3); i++) {
                    const file = e.target.files[i];
                    if(file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            const img = document.createElement('img');
                            img.src = e.target.result;
                            img.style.width = '80px';
                            img.style.height = '80px';
                            img.style.objectFit = 'cover';
                            img.style.borderRadius = '4px';
                            previewContainer.appendChild(img);
                        }
                        reader.readAsDataURL(file);
                    }
                }
            });

            // 点击模态框外部关闭 (针对主回复模态框)
            document.getElementById('replyModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeReplyModal();
                }
            });

            // 确保内联回复框初始隐藏并从DOM中分离（如果是共享元素）
            const inlineReplyBox = document.getElementById('inlineReplyBox');
            if (inlineReplyBox && inlineReplyBox.parentNode) {
                inlineReplyBox.parentNode.removeChild(inlineReplyBox);
            }
            document.body.appendChild(inlineReplyBox); // 保留在body中，更容易管理 display:none
            inlineReplyBox.style.display = 'none';
        });

        // 打开图片模态框
        function openImageModal(src) {
            const modal = document.getElementById('imageModal');
            const modalImg = document.getElementById('modalImageSrc');
            if (modal && modalImg) {
                modal.style.display = "flex"; // 使用 flex 以便 CSS 中的 align-items 和 justify-content 生效
                modalImg.src = src;
                document.body.style.overflow = 'hidden'; // 禁止背景滚动
            }
        }

        // 关闭图片模态框
        function closeImageModal() {
            const modal = document.getElementById('imageModal');
            if (modal) {
                modal.style.display = "none";
                document.body.style.overflow = 'auto'; // 恢复背景滚动
            }
        }
    </script>

    <!-- 图片模态框 -->
    <div id="imageModal" class="image-modal">
        <span class="close-modal-btn" onclick="closeImageModal()">&times;</span>
        <img class="modal-content-image" id="modalImageSrc">
    </div>
</body>
</html>
